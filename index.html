<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Crypto Price Action + Volume Profile • Binance</title>
  <script src="https://cdn.jsdelivr.net/npm/lightweight-charts@4.1.3/dist/lightweight-charts.standalone.production.min.js"></script>
  <style>
    body {
      margin: 0;
      font-family: system-ui, sans-serif;
      background: #0f0f1a;
      color: #e2e8f0;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }
    header {
      padding: 12px 20px;
      background: linear-gradient(135deg, #1e293b, #111827);
      border-bottom: 1px solid #334155;
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      gap: 12px;
    }
    h1 { margin: 0; font-size: 1.45rem; color: #c7d2fe; }
    .controls { display: flex; gap: 10px; flex-wrap: wrap; }
    select, button {
      padding: 9px 16px;
      background: #1e293b;
      color: #e2e8f0;
      border: 1px solid #475569;
      border-radius: 6px;
      font-size: 0.92rem;
      cursor: pointer;
    }
    button { background: #6366f1; border-color: #6366f1; font-weight: 600; }
    button:hover { background: #4f46e5; }
    #chart { flex: 1; min-height: 500px; }
    #status {
      position: absolute;
      bottom: 16px;
      left: 16px;
      background: rgba(15,23,42,0.85);
      padding: 10px 16px;
      border-radius: 8px;
      font-size: 0.9rem;
      z-index: 10;
      max-width: 90%;
    }
    .buy  { color: #34d399; font-weight: bold; }
    .sell { color: #f87171; font-weight: bold; }
  </style>
</head>
<body>

<header>
  <h1>Crypto Price Action + Volume Profile</h1>
  <div class="controls">
    <select id="symbol">
      <option value="BTCUSDT" selected>BTC/USDT</option>
      <option value="ETHUSDT">ETH/USDT</option>
      <option value="SOLUSDT">SOL/USDT</option>
      <option value="BNBUSDT">BNB/USDT</option>
      <option value="XRPUSDT">XRP/USDT</option>
      <option value="ADAUSDT">ADA/USDT</option>
      <option value="DOGEUSDT">DOGE/USDT</option>
      <option value="TRXUSDT">TRX/USDT</option>
      <option value="LINKUSDT">LINK/USDT</option>
      <option value="SUIUSDT">SUI/USDT</option>
      <option value="TONUSDT">TON/USDT</option>
      <option value="AVAXUSDT">AVAX/USDT</option>
    </select>
    <select id="interval">
      <option value="15m">15 min</option>
      <option value="30m">30 min</option>
      <option value="1h" selected>1 hour</option>
      <option value="4h">4 hours</option>
      <option value="1d">Daily</option>
    </select>
    <button onclick="loadChart()">Load / Refresh</button>
  </div>
</header>

<div id="chart"></div>
<div id="status">Ready — click Load to start</div>

<script>
let chart = null;
let candleSeries = null;
let vpSeries = null;
let pocLine = null;
let zoneSeries = [];

const status = document.getElementById('status');

function binanceToCandle(kline) {
  return {
    time:   Math.floor(kline[0] / 1000),
    open:   parseFloat(kline[1]),
    high:   parseFloat(kline[2]),
    low:    parseFloat(kline[3]),
    close:  parseFloat(kline[4]),
    volume: parseFloat(kline[5])
  };
}

// ─── Volume Profile (simple visible range approximation) ───
function buildVolumeProfile(candles) {
  if (candles.length < 10) return { data: [], poc: null };

  let min = Infinity, max = -Infinity, totalVol = 0;
  candles.forEach(c => {
    min = Math.min(min, c.low);
    max = Math.max(max, c.high);
    totalVol += c.volume;
  });

  const range = max - min;
  if (range <= 0) return { data: [], poc: null };

  const bins = new Array(60).fill(0);
  const binSize = range / 60;

  candles.forEach(c => {
    const lowBin  = Math.floor((c.low  - min) / binSize);
    const highBin = Math.floor((c.high - min) / binSize);
    const volPer  = c.volume / (highBin - lowBin + 1 || 1);
    for (let b = lowBin; b <= highBin; b++) {
      if (b >= 0 && b < 60) bins[b] += volPer;
    }
  });

  let maxVol = 0, pocBin = 0;
  bins.forEach((v,i) => { if (v > maxVol) { maxVol = v; pocBin = i; }});

  const pocPrice = min + (pocBin + 0.5) * binSize;

  const maxBinVol = Math.max(...bins);
  const data = bins.map((vol, i) => ({
    time:  min + (i + 0.5) * binSize,
    value: maxBinVol ? (vol / maxBinVol) * 80 : 0,
    color: 'rgba(59, 130, 246, 0.65)'
  }));

  return { data, poc: pocPrice };
}

// ─── Supply / Demand zones (simple swing points) ───
function findZones(candles, lookback = 6) {
  const supports = [], resistances = [];
  for (let i = lookback; i < candles.length - lookback; i++) {
    const c = candles[i];
    let isLow  = true, isHigh = true;
    for (let j = 1; j <= lookback; j++) {
      if (candles[i-j].low  <= c.low)  isLow  = false;
      if (candles[i+j].low  <= c.low)  isLow  = false;
      if (candles[i-j].high >= c.high) isHigh = false;
      if (candles[i+j].high >= c.high) isHigh = false;
    }
    if (isLow)  supports.push(c.low);
    if (isHigh) resistances.push(c.high);
  }

  const merge = arr => {
    if (!arr.length) return [];
    arr.sort((a,b)=>a-b);
    const res = [arr[0]];
    for (let i = 1; i < arr.length; i++)
      if (Math.abs(arr[i] - res[res.length-1]) / res[res.length-1] > 0.005)
        res.push(arr[i]);
    return res;
  };

  return { supports: merge(supports), resistances: merge(resistances) };
}

// ─── Basic pattern markers ───
function detectPatterns(candles) {
  const markers = [];
  for (let i = 1; i < candles.length; i++) {
    const p = candles[i-1], c = candles[i];
    const body = Math.abs(c.close - c.open);
    const range = c.high - c.low;
    const upper = c.high - Math.max(c.open, c.close);
    const lower = Math.min(c.open, c.close) - c.low;

    if (lower > 2 * body && upper < body * 0.5)
      markers.push({ time: c.time, position: 'belowBar', color: '#10b981', shape: 'arrowUp',   text: 'Hammer' });
    if (upper > 2 * body && lower < body * 0.5)
      markers.push({ time: c.time, position: 'aboveBar', color: '#ef4444', shape: 'arrowDown', text: 'Shooting Star' });
    if (body < range * 0.1 && Math.max(upper, lower) < range * 0.15)
      markers.push({ time: c.time, position: 'aboveBar', color: '#fbbf24', shape: 'circle',    text: 'Doji' });

    if (p.close < p.open && c.close > c.open && c.open <= p.close && c.close >= p.open)
      markers.push({ time: c.time, position: 'belowBar', color: '#059669', shape: 'circle', text: 'Bull Engulf' });
    if (p.close > p.open && c.close < c.open && c.open >= p.close && c.close <= p.open)
      markers.push({ time: c.time, position: 'aboveBar', color: '#dc2626', shape: 'circle', text: 'Bear Engulf' });
  }
  return markers;
}

async function loadChart() {
  const symbol   = document.getElementById('symbol').value;
  const interval = document.getElementById('interval').value;
  status.textContent = `Loading ${symbol} ${interval}...`;

  try {
    const resp = await fetch(`https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=${interval}&limit=400`);
    if (!resp.ok) throw new Error('Binance fetch failed');
    const data = await resp.json();
    if (!data.length) throw new Error('No data returned');

    const candles = data.map(binanceToCandle);

    if (!chart) {
      chart = LightweightCharts.createChart(document.getElementById('chart'), {
        width: document.getElementById('chart').clientWidth,
        height: document.getElementById('chart').clientHeight,
        layout: { background: { type: 'solid', color: '#0f0f1a' }, textColor: '#d1d5db' },
        grid: { vertLines: { color: '#1e293b' }, horzLines: { color: '#1e293b' } },
        timeScale: { timeVisible: true, secondsVisible: false },
        rightPriceScale: { borderColor: '#334155' },
        leftPriceScale: { visible: true, borderColor: '#334155' }
      });

      candleSeries = chart.addCandlestickSeries({
        upColor: '#10b981', downColor: '#ef4444',
        wickUpColor: '#10b981', wickDownColor: '#ef4444',
        borderVisible: false
      });

      vpSeries = chart.addHistogramSeries({
        color: 'rgba(59,130,246,0.55)',
        priceScaleId: 'left',
        priceLineVisible: false,
        lastValueVisible: false
      });
    }

    candleSeries.setData(candles);

    // Clear old markers & zones
    candleSeries.setMarkers([]);
    zoneSeries.forEach(s => chart.removeSeries(s)); zoneSeries = [];
    if (pocLine) { chart.removeSeries(pocLine); pocLine = null; }

    // Zones
    const { supports, resistances } = findZones(candles);
    const tStart = candles[0].time - 86400*2;
    const tEnd   = candles[candles.length-1].time + 86400*2;

    supports.forEach(price => {
      const s = chart.addLineSeries({ color: '#22c55e', lineWidth: 1, lineStyle: 2 });
      s.setData([{time:tStart, value:price}, {time:tEnd, value:price}]);
      zoneSeries.push(s);
    });

    resistances.forEach(price => {
      const s = chart.addLineSeries({ color: '#ef4444', lineWidth: 1, lineStyle: 2 });
      s.setData([{time:tStart, value:price}, {time:tEnd, value:price}]);
      zoneSeries.push(s);
    });

    // Patterns
    const markers = detectPatterns(candles);
    if (markers.length) candleSeries.setMarkers(markers);

    // Volume Profile
    const vp = buildVolumeProfile(candles);
    vpSeries.setData(vp.data);

    if (vp.poc) {
      pocLine = chart.addLineSeries({ color: '#f97316', lineWidth: 2, lineStyle: 2 });
      pocLine.setData([{time:tStart, value:vp.poc}, {time:tEnd, value:vp.poc}]);
    }

    // Final status
    status.innerHTML = `${markers.length} patterns detected • POC ≈ ${vp.poc ? vp.poc.toFixed(2) : '—'}`;

    chart.timeScale().fitContent();

  } catch (err) {
    status.textContent = 'Error: ' + err.message;
    console.error(err);
  }
}

window.addEventListener('load', loadChart);
window.addEventListener('resize', () => {
  if (chart) chart.applyOptions({
    width: document.getElementById('chart').clientWidth,
    height: document.getElementById('chart').clientHeight
  });
});
</script>
</body>
</html>
